Create three files: index.html, style.css, main.js.

index.html:
- Include a <canvas id="game" width="900" height="600"></canvas>
- Include a small UI area with:
  - a <div id="hud"></div> for instructions/status
  - a <button id="newRollBtn">New Roll</button>
- Link style.css and main.js (regular script tag, not type="module").

style.css:
- Center the canvas on the page.
- Give canvas a visible border.
- Keep styling minimal.

main.js:
- Get the canvas + 2D context.
- Write a draw() function that clears the canvas and draws a placeholder background color.
- Call draw() once on load.
- Set #hud text to basic instructions.

DONE WHEN:
Opening index.html shows a bordered canvas and the HUD text, with no console errors.

In main.js, replace the single draw() call with a game loop using requestAnimationFrame.

Requirements:
- Track lastTime and compute deltaTime in seconds.
- Have update(dt) and render() functions.
- The loop calls update(dt) then render() each frame.
- For now update(dt) does nothing.

DONE WHEN:
The loop runs without errors and the canvas still renders properly.

In main.js, define constants for the lane:
- laneX, laneY, laneW, laneH (a long rectangle centered in the canvas)
- optional gutter width

In render():
- Clear canvas.
- Draw lane rectangle (one color) and surrounding area (another color).
- Draw a foul line near the bottom of the lane.

DONE WHEN:
You see a clear lane area centered on the canvas.\
//

Add a ball object with:
- radius
- position (x,y)
- velocity (vx,vy)
- state: "AIMING" or "ROLLING"

Place ball at the bottom of the lane in AIMING state.
Controls:
- Left/Right arrows move the ball’s x position while AIMING.
- Clamp ball.x so it stays inside lane bounds.

Render the ball as a circle.

DONE WHEN:
Left/Right moves the ball smoothly side to side at the lane bottom.
//
Add power charging while AIMING:
- On Space keydown: start charging (if not already).
- While charging, increase power from 0 to maxPower repeatedly clamped.
- On Space keyup: launch the ball and switch to ROLLING.

Launch behavior:
- Set ball.vy to a negative value based on power (ball rolls up the lane).
- ball.vx = 0 for now (straight shot).

UI:
- Draw a simple power bar on the canvas (or in HUD).
- Show current power value.

DONE WHEN:
Holding Space increases the bar, releasing Space launches the ball up the lane.
//

In update(dt) while ROLLING:
- Apply friction to ball velocity (simple damping).
- Update ball position by velocity * dt.
- If speed drops below a threshold OR ball goes off the top of lane, end the roll.

End-of-roll behavior:
- Set ball.vx = ball.vy = 0.
- Switch to a new state "SETTLE" (we’ll use it later).
- Show a HUD message "Roll ended".

DONE WHEN:
Ball moves, slows down, and the roll ends cleanly.
//

Add pins:
- Represent each pin as an object: x, y, vx, vy, r, startX, startY, down(boolean)
- Create 10 pins arranged in a triangle near the top of the lane.
- Render pins as circles. If pin.down is true, render it in a lighter/transparent way.

DONE WHEN:
Pins appear in a triangle formation near the top of the lane.

Implement ball–pin collisions during ROLLING:
- For each pin not down:
  - Check circle collision: distance < (ball.r + pin.r)
  - If collision:
    - Compute collision normal (nx, ny) from ball to pin.
    - Push pin by setting pin.vx and pin.vy in the normal direction scaled by an impulse constant.
    - Slightly reduce ball velocity (multiply by e.g. 0.9).
    - Also separate them minimally to prevent sticking (move pin along normal by overlap).

Ignore pin-pin collisions for now.

DONE WHEN:
Rolling into pins causes pins to move away from the ball.

Update pins each frame:
- Apply friction/damping to pin velocities.
- Update pin positions.

Down detection:
- A pin becomes down if distance from (startX,startY) > DOWN_DISTANCE (e.g., 25px)
  OR if it leaves lane bounds.
- When down, you can keep it moving or stop it; but it should count as knocked.

DONE WHEN:
Pins move after being hit and eventually are marked down.

Implement SETTLE state:
- When the roll ends, keep updating pins for a short time until they slow down.
- If all pin speeds are below a small threshold for (say) 0.5s, finalize results:
  - Count knocked pins = number of pins with down === true
  - Display "Pins knocked: X" in HUD
  - Switch state to "RESULT"

New Roll:
- Clicking #newRollBtn resets ball and pins to initial positions and returns to AIMING.
- Also add key "R" to reset.

DONE WHEN:
After a roll, you see "Pins knocked: X", and New Roll resets everything.

Refactor main.js lightly:
- Move all tunable numbers into constants at the top: FRICTION_BALL, FRICTION_PIN, MAX_POWER, POWER_CHARGE_RATE, IMPULSE, DOWN_DISTANCE, etc.
- Add clear comments for: input handling, update loop, collision math, states.
- Ensure there are no unused variables and no console errors.

DONE WHEN:
The code is easy to read and tweaking constants changes behavior predictably.




